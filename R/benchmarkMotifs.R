##' Benchmark linear motif instance found using QSLIMFinder (SLIMFinder)
##' @rdname benchmarkMotifs
##' @name benchmarkMotifs
##' @author Vitalii Kleshchevnikov
##' @param occurence_file a path to a tsv (txt) file containing QSLIMFinder (SLIMFinder) occurence output
##' @param main_file a path to a tsv (txt) file containing QSLIMFinder (SLIMFinder) main output
##' @param domain_res_file path to RData containing objects generated by what_we_find_VS_ELM.Rmd script (specifically \code{domain_results_obj} object)
##' @param motif_setup path to RData containing objects generated by PPInetwork2SLIMFinder pipeline (specifically \code{motif_input_obj} object)
##' @param domain_results_obj character, name of the object containing domain enrichment results (class == XYZinteration_XZEmpiricalPval)
##' @param motif_input_obj character, name of the object of class InteractionSubsetFASTA_list containing: FASTA sequences for interacting proteins, molecular interaction data they correspond to. Each element of a list contains input for individual QSLIMFinder run.
##' @param one_from_cloud use only one top motif from motif cloud
##' @param dbfile_main a path to a gff (txt) file containing ELM database motif occurrences (proteins in the main set)
##' @param dburl_main url where to get ELM database containing motif occurrences (proteins in the main set)
##' @param dbfile_query a path to a gff (txt) file containing ELM database motif occurrences (proteins in the query set)
##' @param dburl_query url where to get ELM database containing motif occurrences (proteins in the query set)
##' @param query_res_query_only return only GRanges for query proteins, passed to "GRangesINinteractionSubsetFASTA". Do not change the default value.
##' @param motif_types character vector of motif types
##' @param all_res_excl_query all results in the output is all occurences excluding the query proteins. If FALSE, all results include occurences in all proteins.
##' @param merge_motif_variants If FALSE (default) merge motif occurences only if motifs are variants of the same motif (such as TRG_NLS).
##' @param seed when using random negative sets (\code{neg_set = "random"}): seed for RNG for sampling
##' @param N when using random negative sets (\code{neg_set = "random"}): number of samples
##' @param replace when using random negative sets (\code{neg_set = "random"}): sample starts of GRanges with replacement \link{randomGRanges}
##' @param within1sequence when using random negative sets (\code{neg_set = "random"}): resample GRanges within one sequence or across sequences \link{randomGRanges}. If seq 1 has two motifs of length 4 and 7 and \code{within1sequence = TRUE} two motifs of the same length 4 and 7 will be sampled from the same protein. If \code{within1sequence = FALSE} two motifs of the same length 4 and 7 will be sampled from any protein in the set used for benchmarking.
##' @param all_predictor_col "Sig"
##' @param query_predictor_col "Sig" or "p.value" or "domain_motif_pval"
##' @param normalise logical, normalise predictor value, just in case predictor doesn't span the full range between 0 ... 1
##' @param minoverlap integer, passed to \code{\link[GenomicRanges]{findOverlaps}}
##' @param maxgap integer, passed to \code{\link[GenomicRanges]{findOverlaps}}
##' @param minoverlap_redundant for removing motif classes that match the same occurence
##' @param filter_by_domain_data criteria to filter domain data and restrict motif search datasets (for example, "p.value < 0.05" or "fdr_pval < 0.05 & domain_count_per_IDs_interactor_viral > 1")
##' @param select_predictor_per_range function (such as min) that select predictor value if multiple values (such as returned by multiple datasets or multiple domains integrated) describe the same range
##' @param ... other arguments passed to passed to \code{\link[GenomicRanges]{findOverlaps}}
##' @return object class \code{benchmarkMotifsResult) containing occurence (GRanges), instances_all (GRanges, known instances in all proteins or all excluding the query proteins), instances_query (GRanges, known instances in query proteins), predictions_all (for ROCR), labels_all (for ROCR), predictions_query (for ROCR), labels_query (for ROCR), overlapping_GRanges_all (GRanges, known instances that we also found), overlapping_GRanges_query(GRanges, known instances that we also found), N_query_prot_with_known_instances, N_query_known_instances, N_all_prot_with_known_instances, N_all_known_instances
##' @import GenomicRanges
##' @import GenomeInfoDb
##' @import data.table
##' @export benchmarkMotifs
##' @seealso \code{\link{ELMdb2GRanges}}, \code{\link{findOverlapsBench}}
benchmarkMotifs = function(occurence_file = "../viral_project/SLIMFinder_Vidal/result/occurence.txt",
                           main_file = "../viral_project/SLIMFinder_Vidal/result/main_result.txt",
                           domain_res_file = "../viral_project/processed_data_files/what_we_find_VS_ELM_clust20171019.RData",
                           motif_setup = "../viral_project/processed_data_files/QSLIMFinder_instances_h2v_Vidal_clust201710.RData",
                           neg_set = c("random", "all_instances", "all_proteins")[1],
                           domain_results_obj = "res_count", motif_input_obj = "forSLIMFinder_Ready",
                           one_from_cloud = T,
                           dbfile_main = "../viral_project/data_files/instances_all.gff",
                           dburl_main = "http://elm.eu.org/instances.gff?q=None&taxon=Homo%20sapiens&instance_logic=",
                           dbfile_query = "../viral_project/data_files/instances_query.gff",
                           dburl_query = "http://elm.eu.org/instances.gff?q=all&taxon=irus&instance_logic=",
                           query_res_query_only = T, motif_types = c("DOC", "MOD", "LIG", "DEG", "CLV", "TRG"),
                           all_res_excl_query = T, merge_motif_variants = F,
                           seed = 21, N = 100, replace = T, within1sequence = T,
                           query_predictor_col = "Sig", all_predictor_col = "Sig", normalise = T,
                           minoverlap = 2, maxgap = 0,
                           minoverlap_redundant = 5,
                           merge_domain_data = T,
                           merge_by_occurence_mcols = c("query", "interacts_with"),
                           merge_by_domain_res_cols = c("IDs_interactor_viral", "IDs_interactor_human"),
                           count_ranges_by = list(by = "IDs_domain_human", name = "motif_occ_per_domain",
                                                  normalise_by = "domain_count", normalised_name = "normalised_motif_occ_per_domain"),
                           filter_by_domain_data = "p.value < 0.05",
                           select_predictor_per_range = min, ...) {

  ### Load domain enrichment results, PPI data, and data used for QSLIMfinder
  domain_res_env = R.utils::env(load(domain_res_file))
  domain_res = domain_res_env[[domain_results_obj]]
  rm(domain_res_env)

  if(file.exists(paste0(motif_setup, ".zip"))) {
    unzip(zipfile = paste0(motif_setup, ".zip"), exdir = ".") # dirname(paste0(motif_setup, ".zip"))
    motif_setup_env = R.utils::env(load(motif_setup))
    unlink(motif_setup)
  } else {
    motif_setup_env = R.utils::env(load(motif_setup))
  }

  forSLIMFinder_Ready = motif_setup_env[[motif_input_obj]]
  rm(motif_setup_env)

  # keep only SLIMFinder datasets where seed protein - query protein pair matches filtering criteria
  domain_res = XYZ.p.adjust(domain_res, adj_by = "p.value")
  if(!is.null(filter_by_domain_data)){
    eval(parse(text = paste0("domain_res$data_with_pval = domain_res$data_with_pval[",filter_by_domain_data,"]")))
    forSLIMFinder_Ready = domainProteinPairMatch(forSLIMFinder_Ready, domain_res, remove = T)
  }

  ### Load QSLIMFinder results and ELM data
  occurence = SLIMFinderOcc2GRanges(occurence_file = occurence_file,
                                    main_file = main_file,
                                    one_from_cloud = one_from_cloud)
  instances_all = ELMdb2GRanges(dbfile = dbfile_main,
                                dburl = dburl_main,
                                tsvurl = gsub("gff", "tsv", dburl_main),
                                tsvfile = gsub("gff", "tsv", dbfile_main))
  instances_query = ELMdb2GRanges(dbfile = dbfile_query,
                                  dburl = dburl_query,
                                  tsvurl = gsub("gff", "tsv", dburl_query),
                                  tsvfile = gsub("gff", "tsv", dbfile_query))

  ### Filter ELM instances by instance logic == "true positive"
  instances_all = instances_all[instances_all$InstanceLogic == "true positive"]
  instances_query = instances_query[instances_query$InstanceLogic == "true positive"]
  table(instances_all$InstanceLogic)

  ### Filter ELM instances located in proteins that we use to search for motifs and select motif types of interest
  searched_all = GRangesINinteractionSubsetFASTA(grange = instances_all, interactionSubsetFASTA = forSLIMFinder_Ready)
  message(paste0(sum(searched_all$granges_in_sequences_Searched), " occurences out of ", length(searched_all$granges_in_sequences_Searched), " total in ELM could have been discovered (all proteins, all types of motifs)"))
  instances_all = instances_all[searched_all$granges_in_sequences_Searched]
  instances_all = filterBYmotifType(instances_all, motif_types = motif_types)
  seqlevels(instances_all) <- seqlevelsInUse(instances_all)
  seqlengths(instances_all) = searched_all$seqlengths[names(seqlengths(instances_all))]


  searched_query = GRangesINinteractionSubsetFASTA(grange = instances_query, interactionSubsetFASTA = forSLIMFinder_Ready, query_only = query_res_query_only)
  message(paste0(sum(searched_query$granges_in_sequences_Searched), " occurences out of ", length(searched_query$granges_in_sequences_Searched), " total in ELM in query proteins could have been discovered (QSLIMFinder query proteins, all types of motifs)"))
  instances_query = instances_query[searched_query$granges_in_sequences_Searched]
  instances_query = filterBYmotifType(instances_query, motif_types = motif_types)
  seqlevels(instances_query) <- seqlevelsInUse(instances_query)
  seqlengths(instances_query) = searched_query$seqlengths[names(seqlengths(instances_query))]

  ### Remove redundancy in known instances
  instances_all = reduceOverlappingGRanges(instances_all, minoverlap = minoverlap_redundant, merge_motif_variants = merge_motif_variants)
  instances_query = reduceOverlappingGRanges(instances_query, minoverlap = minoverlap_redundant, merge_motif_variants = merge_motif_variants)

  #igraph::plot.igraph(overlapping_instances_graph, vertex.size = 1, arrow.mode = "-", vertex.label.cex = 0.6)

  ### Filter discovered occurences to keep query occurences only
  found_in_query = GRangesINinteractionSubsetFASTA(grange = occurence, interactionSubsetFASTA = forSLIMFinder_Ready, query_only = T)
  occurence_query = occurence[found_in_query$granges_in_sequences_Searched]
  # keep only cases when we found a motif in a query protein when that protein was a query
  occurence_query = occurence_query[seqnames(occurence_query) == occurence_query$query]
  ## filter by predicted motif type
  seqlevels(occurence_query) <- seqlevelsInUse(occurence_query)
  seqlengths(occurence_query) = found_in_query$seqlengths[names(seqlengths(occurence_query))]

  suppressWarnings({
    if(all_res_excl_query){
      instances_all = subsetByOverlaps(instances_all, instances_query, type = "equal", invert = T)
    } else instances_all = c(instances_all, subsetByOverlaps(instances_query, instances_all, type = "equal", invert = T))
  })

  # normalise, just in case predictor doesn't span the full range 0 ... 1
  if(normalise) {
    occurence_query$Sig_not_normalised = occurence_query$Sig
    occurence_query$Sig = occurence_query$Sig/max(occurence_query$Sig)
    occurence$Sig_not_normalised = occurence$Sig
    occurence$Sig = occurence$Sig/max(occurence$Sig)
  }

  if(merge_domain_data){
    occurence_query = merge2GRangesmcols(occurence_query, domain_res$data_with_pval,
                                         by.x = merge_by_occurence_mcols,
                                         by.y = merge_by_domain_res_cols)

    occurence_temp = split(occurence_query, mcols(occurence_query)[,count_ranges_by$by])
    count = sapply(occurence_temp, function(per_domain, count_ranges_by) {
      domain_name = unique(mcols(per_domain)[,count_ranges_by$by])
      length(unique(per_domain))
    }, count_ranges_by)
    mcols(occurence_query)[, count_ranges_by$name] = count[match(mcols(occurence_query)[,count_ranges_by$by], names(count))]
    mcols(occurence_query)[, count_ranges_by$normalised_name] = mcols(occurence_query)[, count_ranges_by$name] / mcols(occurence_query)[, count_ranges_by$normalise_by]
    occurence_query$domain_motif_pval = 1 - (1 - occurence_query$Sig) * (1 - occurence_query$p.value)
  }


  ######################### Negative set: ranges in random locations ######################### START
  if(neg_set == "random") {
    ### Generate random negative sets
    set.seed(seed)
    random_instances_all = randomGRanges(instances_all, N = N, replace = replace, within1sequence = within1sequence)
    random_instances_query = randomGRanges(instances_query, N = N, replace = replace, within1sequence = within1sequence)

    ### Combine positive and negative datasets
    combined_instances_all = lapply(random_instances_all, function(random_instance, instances_all){
      c(instances_all, random_instance)
    },instances_all)
    combined_instances_query = lapply(random_instances_query, function(random_instance, instances_query){
      c(instances_query, random_instance)
    },instances_query)

    ### Find overlaps with predicted motifs
    # All
    suppressWarnings({
      predictions_all = lapply(combined_instances_all, function(inst){
        findOverlapsBench(occuring = occurence, benchmarking = inst, predictor_col = all_predictor_col,
                          labels_col = "for_benchmarking", normalise = normalise,
                          maxgap = maxgap, minoverlap = minoverlap,
                          select_predictor_per_range = select_predictor_per_range, ...)$for_ROC$predictions
      })
      labels_all = lapply(combined_instances_all, function(inst){
        labels = findOverlapsBench(occuring = occurence, benchmarking = inst, predictor_col = all_predictor_col,
                                   labels_col = "for_benchmarking", normalise = normalise,
                                   maxgap = maxgap, minoverlap = minoverlap,
                                   select_predictor_per_range = select_predictor_per_range, ...)$for_ROC$labels
        labels[grepl("1",labels)] = 1
        labels
      })
    })
    # Query
    suppressWarnings({
      predictions_query = lapply(combined_instances_query, function(inst){
        findOverlapsBench(occuring = occurence_query, benchmarking = inst, predictor_col = query_predictor_col,
                          labels_col = "for_benchmarking", normalise = normalise,
                          maxgap = maxgap, minoverlap = minoverlap,
                          select_predictor_per_range = select_predictor_per_range, ...)$for_ROC$predictions
      })
      labels_query = lapply(combined_instances_query, function(inst){
        labels = findOverlapsBench(occuring = occurence_query, benchmarking = inst, predictor_col = query_predictor_col,
                                   labels_col = "for_benchmarking", normalise = normalise,
                                   maxgap = maxgap, minoverlap = minoverlap,
                                   select_predictor_per_range = select_predictor_per_range, ...)$for_ROC$labels
        labels[grepl("1",labels)] = 1
        labels
      })
    })
  }
  ######################### Negative set: ranges in random locations #########################  END

  ######################### Negative set: protein in ELM, motif not in ELM  ######################### START
  if(neg_set == "all_instances"){
    ## query proteins
    combined_instances_query = instances_query
    occurence_query = occurence_query[seqnames(occurence_query) %in% seqnames(instances_query)]
    TP_FN = findOverlapsBench(occuring = occurence_query,
                              benchmarking = instances_query,
                              predictor_col = query_predictor_col,
                              labels_col = "for_benchmarking",
                              normalise = normalise,
                              maxgap = maxgap,
                              minoverlap = minoverlap,
                              select_predictor_per_range = select_predictor_per_range)
    TP_FN$for_ROC$labels = 1

    FP = subsetByOverlaps(occurence_query, TP_FN$overlapping_GRanges, type = "equal", invert = T)
    FP$for_benchmarking = 0
    res = data.frame(predictions = 1 - mcols(FP)[,query_predictor_col], labels = mcols(FP)[,"for_benchmarking"], stringsAsFactors = F)
    res = rbind(res, TP_FN$for_ROC)

    predictions_query = res$predictions
    labels_query = res$labels


    ## all proteins
    combined_instances_all = instances_all
    occurence = occurence[seqnames(occurence) %in% seqnames(instances_all)]
    TP_FN_all = findOverlapsBench(occuring = occurence,
                                  benchmarking = instances_all,
                                  predictor_col = all_predictor_col,
                                  labels_col = "for_benchmarking",
                                  normalise = normalise,
                                  maxgap = maxgap,
                                  minoverlap = minoverlap,
                                  select_predictor_per_range = select_predictor_per_range)
    TP_FN_all$for_ROC$labels = 1

    FP_all = subsetByOverlaps(occurence, TP_FN_all$overlapping_GRanges, type = "equal", invert = T)
    FP_all$for_benchmarking = 0
    res_all = data.frame(predictions = 1 - mcols(FP_all)[,all_predictor_col], labels = mcols(FP_all)[,"for_benchmarking"], stringsAsFactors = F)
    res_all = rbind(res_all, TP_FN_all$for_ROC)

    predictions_all = res_all$predictions
    labels_all = res_all$labels
  }
  ######################### Negative set: protein in ELM, motif not in ELM  ######################### END

  ######################### Negative set: protein not in ELM or protein in ELM but motif not in ELM  ######################### START
  if(neg_set == "all_proteins"){
    ## query proteins
    combined_instances_query = instances_query

    TP_FN = findOverlapsBench(occuring = occurence_query,
                              benchmarking = instances_query,
                              predictor_col = query_predictor_col,
                              labels_col = "for_benchmarking",
                              normalise = normalise,
                              maxgap = maxgap,
                              minoverlap = minoverlap,
                              select_predictor_per_range = select_predictor_per_range)
    TP_FN$for_ROC$labels = 1

    FP = subsetByOverlaps(occurence_query, TP_FN$overlapping_GRanges, type = "equal", invert = T)
    FP$for_benchmarking = 0
    res = data.frame(predictions = 1 - mcols(FP)[,query_predictor_col], labels = mcols(FP)[,"for_benchmarking"], stringsAsFactors = F)
    res = rbind(res, TP_FN$for_ROC)

    predictions_query = res$predictions
    labels_query = res$labels
    labels_query[grepl("1",labels_query)] = 1

    ## all proteins
    combined_instances_all = instances_all

    TP_FN_all = findOverlapsBench(occuring = occurence,
                                  benchmarking = instances_all,
                                  predictor_col = all_predictor_col,
                                  labels_col = "for_benchmarking",
                                  normalise = normalise,
                                  maxgap = maxgap,
                                  minoverlap = minoverlap,
                                  select_predictor_per_range = select_predictor_per_range)
    TP_FN_all$for_ROC$labels = 1

    FP_all = subsetByOverlaps(occurence, TP_FN_all$overlapping_GRanges, type = "equal", invert = T)
    FP_all$for_benchmarking = 0
    res_all = data.frame(predictions = 1 - mcols(FP_all)[,all_predictor_col], labels = mcols(FP_all)[,"for_benchmarking"], stringsAsFactors = F)
    res_all = rbind(res_all, TP_FN_all$for_ROC)

    predictions_all = res_all$predictions
    labels_all = res_all$labels
  }
  ######################### Negative set: protein not in ELM or protein in ELM but motif not in ELM  ######################### END

  ### Get  overlapping instances
  suppressWarnings({
    if(neg_set == "random") {
      combined_instances_all_temp = combined_instances_all[[1]]
      combined_instances_query_temp = combined_instances_query[[1]]
    } else {
      combined_instances_all_temp = combined_instances_all
      combined_instances_query_temp = combined_instances_query
    }

    overlapping_GRanges_all = findOverlapsBench(occuring = occurence,
                                                benchmarking = combined_instances_all_temp,
                                                predictor_col = all_predictor_col,
                                                labels_col = "for_benchmarking",
                                                normalise = normalise,
                                                maxgap = maxgap,
                                                minoverlap = minoverlap)$overlapping_GRanges
    overlapping_GRanges_all = overlapping_GRanges_all[overlapping_GRanges_all$for_benchmarking == 1,]
    overlapping_GRanges_query = findOverlapsBench(occuring = occurence_query,
                                                  benchmarking = combined_instances_query_temp,
                                                  predictor_col = query_predictor_col,
                                                  labels_col = "for_benchmarking",
                                                  normalise = normalise,
                                                  maxgap = maxgap,
                                                  minoverlap = minoverlap)$overlapping_GRanges
    overlapping_GRanges_query = overlapping_GRanges_query[overlapping_GRanges_query$for_benchmarking == 1,]
  })

  ##### KNOWN #####
  motif_protein_table_queryKNOWN = as.data.table(cbind(mcols(instances_query)[, c("ID")], UNIPROT = seqnames(instances_query)))
  # number of proteins with motif
  N_query_prot_with_known_instances = length(unique(as.character(seqnames(instances_query)))) #motif_protein_table_queryKNOWN[, uniqueN(UNIPROT)]#, by = .(ID)]
  # total number of instances
  N_query_known_instances = length(unique(instances_query))

  motif_protein_table_allKNOWN = as.data.table(cbind(mcols(instances_all)[, c("ID")], UNIPROT = seqnames(instances_all)))
  # number of proteins with motif
  N_all_prot_with_known_instances = length(unique(as.character(seqnames(instances_all)))) #motif_protein_table_allKNOWN[, uniqueN(UNIPROT)]#, by = .(ID)]
  # total number of instances
  N_all_known_instances = length(unique(instances_all))

  ##### FOUND #####
  motif_protein_table_query = as.data.table(cbind(mcols(overlapping_GRanges_query)[, c("ID", "Pattern")], UNIPROT = seqnames(overlapping_GRanges_query)))
  # number of proteins with motif
  N_query_prot_with_known_instances_found = length(unique(as.character(seqnames(overlapping_GRanges_query)))) #motif_protein_table_query[, uniqueN(UNIPROT), by = .(ID, Pattern)]
  # total number of instances
  N_query_known_instances_found = length(unique(overlapping_GRanges_query))

  motif_protein_table_all = as.data.table(cbind(mcols(overlapping_GRanges_all)[, c("ID", "Pattern")], UNIPROT = seqnames(overlapping_GRanges_all)))
  # number of proteins with motif
  N_all_prot_with_known_instances_found = length(unique(as.character(seqnames(overlapping_GRanges_all)))) #motif_protein_table_all[, uniqueN(UNIPROT), by = .(ID, Pattern)]
  # total number of instances
  N_all_known_instances_found = length(unique(overlapping_GRanges_all))



  out = list(
    occurence = occurence, occurence_query = occurence_query,
    instances_all = instances_all, instances_query = instances_query,
    predictions_all = predictions_all, labels_all = labels_all,
    predictions_query = predictions_query, labels_query = labels_query,
    overlapping_GRanges_all = overlapping_GRanges_all,
    overlapping_GRanges_query = overlapping_GRanges_query,
    N_query_prot_with_known_instances = N_query_prot_with_known_instances, N_query_known_instances = N_query_known_instances,
    N_all_prot_with_known_instances = N_all_prot_with_known_instances, N_all_known_instances = N_all_known_instances,
    N_query_prot_with_known_instances_found = N_query_prot_with_known_instances_found, N_query_known_instances_found = N_query_known_instances_found,
    N_all_prot_with_known_instances_found = N_all_prot_with_known_instances_found, N_all_known_instances_found = N_all_known_instances_found
  )
  class(out) = "benchmarkMotifsResult"
  out
}

##' Get motifs from the output of benchmarking linear motifs by id
##' @rdname benchmarkMotifs
##' @name queryOCCByMCOL
##' @author Vitalii Kleshchevnikov
##' @param res object class \code{benchmarkMotifsResult), the output of benchmarkMotifs
##' @param keytype character, name of the column that contains key identifiers
##' @param key character, identifiers for which to retrieve the result
##' @return GenomicRanges containing motifs for a given key
##' @import GenomicRanges
##' @import data.table
##' @export queryOCCByMCOL
queryOCCByMCOL = function(res, keytype = "IDs_domain_human", key = "IPR032440"){
  if(class(res) != "benchmarkMotifsResult") stop("res should be of class \"benchmarkMotifsResult\"")
  res$occurence_query[which(mcols(res$occurence_query)[, keytype] == key)]
}

##' Benchmark linear motif instance found using QSLIMFinder (SLIMFinder)
##' @rdname benchmarkMotifs
##' @name mBenchmarkMotifs
##' @author Vitalii Kleshchevnikov
##' @param datasets character vector, names of the datasets ("Vidal" in "./SLIMFinder_Vidal/result/occurence.txt" or "" in "./SLIMFinder/result/occurence.txt")
##' @param descriptions character vector, description of the datasets (title of the ROC plot)
##' @param dir character, base directory. For example, "./" in "./SLIMFinder_Vidal/result/occurence.txt"
##' @param dir_suff character, SLIMFinder results folder prefix. For example, "SLIMFinder" in "./SLIMFinder_Vidal/result/occurence.txt"
##' @return list of objects of class \code{benchmarkMotifsResult)
##' @import GenomicRanges
##' @import data.table
##' @export mBenchmarkMotifs
mBenchmarkMotifs = function(datasets = c("", "Vidal"),
                            descriptions = c("",""),
                            dir = "./",
                            neg_set = c("random", "all_instances", "all_proteins")[1],
                            domain_res_file = "./processed_data_files/what_we_find_VS_ELM_clust20171019.RData",
                            domain_results_obj = "res_count", motif_input_obj = "forSLIMFinder_Ready",
                            one_from_cloud = T, type = "QSLIMFinder",
                            dbfile_main = "./data_files/instances9606.gff",
                            dburl_main = "http://elm.eu.org/instances.gff?q=None&taxon=Homo%20sapiens&instance_logic=",
                            dbfile_query = "./data_files/instances10239.gff",
                            dburl_query = "http://elm.eu.org/instances.gff?q=all&taxon=irus&instance_logic=",
                            query_res_query_only = T, motif_types = c("DOC", "MOD", "LIG", "DEG", "CLV", "TRG"),
                            all_res_excl_query = T,
                            seed = 21, N = 100, replace = T, within1sequence = T,
                            query_predictor_col = "Sig", all_predictor_col = "Sig",normalise = T,
                            minoverlap = 2, maxgap = 0,
                            minoverlap_redundant = 5, merge_motif_variants = F,
                            motif_setup_months = "201710",
                            merge_domain_data = T,
                            merge_by_occurence_mcols = c("query", "interacts_with"),
                            merge_by_domain_res_cols = c("IDs_interactor_viral", "IDs_interactor_human"),
                            count_ranges_by = list(by = "IDs_domain_human", name = "motif_occ_per_domain",
                                                   normalise_by = "domain_count", normalised_name = "normalised_motif_occ_per_domain"),
                            filter_by_domain_data = "p.value < 0.05",
                            select_predictor_per_range = min,
                            dir_suff = ""){

  results = lapply(datasets, function(dataset) {

    description = descriptions[datasets == dataset]
    if(length(motif_setup_months) > 1){
      motif_setup_month = motif_setup_months[datasets == dataset]
    } else motif_setup_month = motif_setup_months


    occurence_file = paste0(dir, dir_suff, dataset, "/result/occurence.txt")
    main_file = paste0(dir, dir_suff, dataset, "/result/main_result.txt")
    motif_setup = paste0(dir,"processed_data_files/QSLIMFinder_instances_h2v_", dataset, "_clust",motif_setup_month,".RData")

    result = benchmarkMotifs(occurence_file = occurence_file,
                             main_file = main_file,
                             domain_res_file = domain_res_file,
                             motif_setup = motif_setup, neg_set = neg_set,
                             domain_results_obj = domain_results_obj, motif_input_obj = motif_input_obj,
                             one_from_cloud = one_from_cloud, type = type,
                             dbfile_main = dbfile_main,
                             dburl_main = dburl_main,
                             dbfile_query = dbfile_query,
                             dburl_query = dburl_query,
                             query_res_query_only = query_res_query_only, motif_types = motif_types,
                             all_res_excl_query = all_res_excl_query,
                             seed = seed, N = N, replace = replace, within1sequence = within1sequence,
                             query_predictor_col = query_predictor_col, all_predictor_col = all_predictor_col, normalise = normalise,
                             minoverlap = minoverlap, maxgap = maxgap,
                             merge_domain_data = merge_domain_data,
                             merge_by_occurence_mcols = merge_by_occurence_mcols,
                             merge_by_domain_res_cols = merge_by_domain_res_cols,
                             minoverlap_redundant = minoverlap_redundant,
                             merge_motif_variants = merge_motif_variants,
                             filter_by_domain_data = filter_by_domain_data,
                             select_predictor_per_range = select_predictor_per_range)

    result$description = description
    result
  })

  resnames = character(length(datasets))
  resnames[datasets != ""] = datasets[datasets != ""]
  resnames[datasets == ""] = "full_Intact"
  names(results) = resnames

  results
}

##' Reduce GRanges keeping metadata (collapsing withing each column separated by pipes)
##' @rdname reduceWithMcols
##' @name reduceWithMcols
##' @author Vitalii Kleshchevnikov
##' @param range any Genomic Ranges object with metadata (mcols())
##' @return reduced Genomic Ranges object
##' @import GenomicRanges
##' @export reduceWithMcols
reduceWithMcols = function(range) {
  metadata = mcols(range)
  for(i in 1:ncol(metadata)) {
    metadata[,i] = paste0(as.character(metadata[,i]), collapse = "|")
  }
  metadata = unique(metadata)
  range = reduce(range, min.gapwidth = 0)
  mcols(range) = metadata
  range
}

##' Generate motif variant class (the first 2 element in the motif names)
##' @rdname motifVariantClass
##' @name motifVariantClass
##' @author Vitalii Kleshchevnikov
##' @param ids character vector of ELM motif IDs
##' @return character vector of ELM motif variant class (such as TRG_NLS or LIG_SH3)
##' @export motifVariantClass
motifVariantClass = function(ids){
  matches = gregexpr("^[[:alnum:]]+_[[:alnum:]]+", ids)
  for (i in seq_along(matches)) {
    ids[i] = substr(ids[i], matches[[i]][1], attr(matches[[i]],"match.length"))
  }
  ids
}

##' Reduce Overlapping GRanges keeping metadata (collapsing withing each column separated by pipes)
##' @rdname reduceOverlappingGRanges
##' @name reduceOverlappingGRanges
##' @author Vitalii Kleshchevnikov
##' @param GRanges any Genomic Ranges object with metadata (mcols())
##' @param minoverlap min overlap between Genomic Ranges to continue with reduce
##' @return reduced Genomic Ranges object
##' @import GenomicRanges
##' @import data.table
##' @export reduceOverlappingGRanges
reduceOverlappingGRanges = function(GRanges, minoverlap = 5, merge_motif_variants = F, ...){
  overlapping_instances = findOverlaps(GRanges, minoverlap = minoverlap, ...)

  overlapping_instances = as.data.frame(overlapping_instances[queryHits(overlapping_instances) < subjectHits(overlapping_instances)])
  overlapping_instances$queryHits = as.character(overlapping_instances$queryHits)
  overlapping_instances$subjectHits = as.character(overlapping_instances$subjectHits)

  overlapping_instances_graph = igraph::graph.edgelist(as.matrix(overlapping_instances), directed = F)
  if(length(igraph::E(overlapping_instances_graph)) > 0){
    overlapping_instances = igraph::fastgreedy.community(overlapping_instances_graph)
    overlapping_instances = data.table(range_indx = as.integer(igraph::V(overlapping_instances_graph)$name), cluster = igraph::membership(overlapping_instances))
    overlapping_instances = overlapping_instances[order(range_indx)]
    non_overlapping_instances = GRanges[-overlapping_instances$range_indx]
    overlapping_instances_ranges = GRanges[overlapping_instances$range_indx]
    overlapping_instances_ranges = split(overlapping_instances_ranges, overlapping_instances$cluster)
    instances_ranges = sapply(overlapping_instances_ranges, function(range, merge_motif_variants){
      if(merge_motif_variants){
        range = reduceWithMcols(range)
      } else {
        motif_variants_classes = split(range, motifVariantClass(range$ID))
        range = sapply(motif_variants_classes, function(motif_variants_class) reduceWithMcols(motif_variants_class))
        range = Reduce(c, range)
      }
      range
    }, merge_motif_variants)

    instances_ranges = Reduce(c, instances_ranges)
    instances_ranges = c(instances_ranges, non_overlapping_instances)
  } else instances_ranges = GRanges

  instances_ranges
}
