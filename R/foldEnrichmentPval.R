##' Find pvalue for each protein-feature pair in the network
##' @name foldEnrichmentPval
##' @name plotFoldEnrichmentDist
##' @description \code{foldEnrichmentPval} calculates how often each fold Enrichment value for the protein-feature pair is as high or higher than the foldEnrichment value for the protein - any (random) feature pairs (obtained from permutations using \code{\link[MItools]{foldEnrichmentDist}}).
##' @description \code{plotFoldEnrichmentDist} allows to visualise sampled fold Enrichment distribution and the real fold Enrichment for the protein-feature pair for specific protein
##' @param fold_enrichment_dist data.table containing fold enrichment for each domain (or other feature) - protein pair (2 columns: IDs_interactor_viral and sampled_fold_enrichment), generated by \code{\link[MItools]{foldEnrichmentDist}}
##' @param data data.table containing foldEnrichment value for each protein-feature pair (4 columns: IDs_interactor_viral, IDs_interactor_human, IDs_domain_human, fold_enrichment)
##' @param cores specify how many cores to use for parallel processing, default (NULL) is to detect all cores on the machine and use all minus one. When using LSF cluster you must specify the number of cores to use because \code{\link[BiocGenerics]{detectCores}} doen't know how much cores you have requested from LSF (with bsub -n) and detects all cores on the actual physical node.
##' @param proteinID character specifying proteinID for which to plot fold Enrichment distribution
##' @param main title for the plot
##' @param text_lab logical: label domains (features) on the plot, or not
##' @param frequency fold enrichment or frequency in a set (if TRUE - frequency)
##' @return data.table containing pvalue for each protein-feature pair in the network (4 columns: proteinID, IDs_interactor_human, featureID, foldEnrichment (or domain_frequency_per_IDs_interactor_viral) and Pval)
##' @usage foldEnrichmentPval(fold_enrichment_dist, data, cores = NULL, frequency = T)
##' plotFoldEnrichmentDist(proteinID, fold_enrichment_dist, data, main = NULL, text_lab = T, frequency = T)
##' @author Vitalii Kleshchevnikov
##' @import data.table
##' @import BiocGenerics
##' @importFrom ggplot2 ggplot
##' @importFrom ggplot2 aes
##' @importFrom ggplot2 geom_histogram
##' @importFrom ggplot2 ggtitle
##' @importFrom ggplot2 xlab
##' @importFrom ggplot2 theme_light
##' @importFrom ggplot2 geom_vline
##' @importFrom ggplot2 theme
##' @importFrom ggplot2 ggplot_build
##' @importFrom ggplot2 geom_text
##' @importFrom ggplot2 facet_wrap
##' @importFrom ggplot2 geom_label
##' @export foldEnrichmentPval
##' @export plotFoldEnrichmentDist
foldEnrichmentPval = function(fold_enrichment_dist, data, cores = NULL, frequency = T){
  # subset data
  if(frequency) data = unique(data[,.(IDs_interactor_viral, IDs_domain_human, domain_frequency_per_IDs_interactor_viral)])
  if(!frequency) data = unique(data[,.(IDs_interactor_viral, IDs_domain_human, fold_enrichment)])
  # split huge foldEnrichment distribution data.table into list of data.tables, one per viral protein ID
  split_fold_enrichment_dist = split(fold_enrichment_dist, fold_enrichment_dist$IDs_interactor_viral)

  # set up parallel processing
  # create cluster
  if(is.null(cores)) cores = detectCores()-1
  cl <- makeCluster(cores)
  # get library support needed to run the code
  clusterEvalQ(cl, {library(data.table); library(MItools)})

  if(frequency){
    # loop over each viral protein and calculate the fraction of sampled_domain_frequency_per_set that is higher or equal to domain_frequency_per_IDs_interactor_viral, write into Pval column and select only necessary columns for minimal representation
    pval_list = parLapply(cl, split_fold_enrichment_dist, function(one_fold_enrichment_dist, data){
      merged = one_fold_enrichment_dist[data, nomatch = 0, on = "IDs_interactor_viral", allow.cartesian = T]
      merged[, Pval := mean(domain_frequency_per_IDs_interactor_viral <= sampled_domain_frequency_per_set), by = IDs_domain_human]
      unique(merged[,.(IDs_interactor_viral, IDs_domain_human, domain_frequency_per_IDs_interactor_viral, Pval)])
    }, data)
  }
  if(!frequency){
    # loop over each viral protein and calculate the fraction of sampled_fold_enrichment that is higher or equal to fold_enrichment, write into Pval column and select only necessary columns for minimal representation
    pval_list = parLapply(cl, split_fold_enrichment_dist, function(one_fold_enrichment_dist, data){
      merged = one_fold_enrichment_dist[data, nomatch = 0, on = "IDs_interactor_viral", allow.cartesian = T]
      merged[, Pval := mean(fold_enrichment <= sampled_fold_enrichment), by = IDs_domain_human]
      unique(merged[,.(IDs_interactor_viral, IDs_domain_human, fold_enrichment, Pval)])
    }, data)
  }


  # stop the cluster
  stopCluster(cl)

  # convert per viral protein list to data.table
  pval_table = Reduce(rbind, pval_list)
  return(pval_table)
}

###########################################

plotFoldEnrichmentDist = function(proteinID, fold_enrichment_dist, data, main = NULL, text_lab = T, frequency = T){

  one_fold_enrichment_dist = fold_enrichment_dist[IDs_interactor_viral %in% proteinID,]
  merged = one_fold_enrichment_dist[data, nomatch = 0, on = "IDs_interactor_viral", allow.cartesian = T]

  if(frequency) merged[, Pval := mean(domain_frequency_per_IDs_interactor_viral <= sampled_domain_frequency_per_set), by = IDs_domain_human]
  if(!frequency) merged[, Pval := mean(fold_enrichment <= sampled_fold_enrichment), by = IDs_domain_human]

  if(is.null(main)) {
    # different plot titles based on frequency vs fold enrichment
    if(frequency) main = paste0("domain frequency per viral protein distribution (sampled using network permutations)")
    if(!frequency) main = paste0("fold enrichment distribution (sampled using network permutations)")
    }

  data2 = unique(merged[,.(IDs_interactor_viral, IDs_domain_human, fold_enrichment, Pval)])[order(fold_enrichment),]
  # generate histogram
  if(frequency) {
    plot = ggplot(merged, aes(x = sampled_domain_frequency_per_set)) +
    geom_histogram() +
    ggtitle(main) + xlab("domain_frequency_per_IDs_interactor_viral") + theme_light() +
    geom_vline(aes(xintercept = domain_frequency_per_IDs_interactor_viral, color = "red")) +
    theme(legend.position = "none") +
    facet_wrap( ~ IDs_interactor_viral, scales = "free")
  }
  if(!frequency) {
    plot = ggplot(merged, aes(x = sampled_fold_enrichment)) +
      geom_histogram() +
      ggtitle(main) + xlab("fold enrichment") + theme_light() +
      geom_vline(aes(xintercept = fold_enrichment, color = "red")) +
      theme(legend.position = "none") +
      facet_wrap( ~ IDs_interactor_viral, scales = "free")
  }
  if(text_lab){
    # take out max count information (to have y position for geom_text) and generate domain label y position
    count = as.data.table(ggplot_build(plot)$data[[1]])
    panel = as.data.table(ggplot_build(plot)$layout$panel_layout)[,.(PANEL, IDs_interactor_viral)]
    max_count_d = count[,.(max_count = max(count)), by = PANEL][,.(PANEL, max_count)]
    max_count_d = max_count_d[panel, nomatch = 0, on = "PANEL"][,.(IDs_interactor_viral,max_count)]
    data2 = data2[max_count_d, on = "IDs_interactor_viral"]
    data2[, y_pos := Pval * max_count]
    # plot domain labels
    if(frequency) plot + geom_text(data = data2, aes(x = domain_frequency_per_IDs_interactor_viral, y = y_pos, label = paste0(IDs_domain_human, ": ", signif(Pval, 3))), inherit.aes = F, size = 2)
    if(!frequency) plot + geom_text(data = data2, aes(x = fold_enrichment, y = y_pos, label = paste0(IDs_domain_human, ": ", signif(Pval, 3))), inherit.aes = F, size = 2)
  }
  if(!text_lab) plot
}
